/*
 * Projet de compilation L3 Miage :
 * Ecriture d'un compilateur
 *
 * auteurs : Matthieu VINCENT, Martin LEMAITRE, Loic REISDOERFER, Mervine LIEFFROY
 * (c) 2017
 */ 


package fr.ul.miage.projet.generated;
import fr.ul.miage.projet.compilateur.Calculatrice;


/* la grammaire */
terminal String NUM, PLUS, MOINS, DIV, MUL, OP, NOM ;
terminal COM, FONCTION, PRINC, PF, PO, AO, AF, PV, V, EG, GLOB, LOC, ENTIER, RET;
terminal APPEL, SI, SINON, OPBOOL, TQ, LIRE, ECRIRE;
non terminal prog, block, fonctionP, blockFonction, affectation, declaration, retourner, conditionnelle, condition; 
non terminal operateur, fonction, parametre, declarationI, parametreA, parametreD, boucle, ecrire;
non terminal String operation, valeur, appel;


start with prog;

//Le programme commence avec un bloc
prog 	::= block 
	 	;

//Un block constitue la partie "hors méthode" du programme et permet de placer chaque élément	
block	::= COM block
		| declaration block
		| fonction block
		| conditionnelle block
		| boucle block
		| ecrire block
		| fonctionP
		;

//Représente la declaration d'une variable global uniquement dans le block "hors méthodes"
declaration ::= GLOB ENTIER parametreD EG operation:chien PV  {: Calculatrice.traduire(chien); :}
		| GLOB ENTIER parametreD EG valeur PV 
		| GLOB ENTIER parametreD PV
		;
		
//Représente les variables décrite lors de leurs déclaration (ex : "glob entier i;" OU "glob entier	i, j, k;")
parametreD ::= NOM V parametreD
			| NOM
			;

//Permet de sélectionner uniquement des atomes du programme
valeur ::= NUM:i {: RESULT = i; :}
		| NOM:i {: RESULT = i; :}
		;
		
//Operation représente tous les calculs réalisablent dans le programme
operation ::= NOM:i operateur:j operation:k		{: RESULT = i+j+k; :}
			| NOM:i operateur:j valeur:k		{: RESULT = i+j+k; :}
			| appel:i operateur:j operation:k	{: RESULT = i+j+k; :}
			| appel:i operateur:j valeur:k		{: RESULT = i+j+k; :}
			| appel:i							{: RESULT = i;:}
			| NUM:i operateur:j operation:k		{: RESULT = i+j+k; :}
			| NUM:i operateur:j valeur:k 		{: RESULT = i+j+k; :}
			| PO operation:i PF operateur:j operation:k {: RESULT = "("+i+")"+j+k; :}
			| PO operation:i PF operateur:j valeur:k 	{: RESULT = "("+i+")"+j+k; :}
			| PO operation:i PF 				{: RESULT = "("+i+")"; :}
			| LIRE operateur:j operation:k		{: RESULT = "lire()"+j+k; :}
			| LIRE operateur:j valeur:k			{: RESULT = "lire()"+j+k; :}
			| LIRE								{: RESULT = "lire()"; :}
			;

//Détermine les operateurs que la grammaire	accepte
operateur	::= PLUS 	{: RESULT = "+"; :}
			| MOINS		{: RESULT = "-"; :}
			| MUL		{: RESULT = "*"; :}
			| DIV		{: RESULT = "/"; :}
			;

//Represente l'affectation d'une valeur oud'un calcul a une variable
affectation ::= NOM EG operation:chien PV //{: Calculatrice.traduire(chien); :}
			| NOM EG valeur PV
			;

//Represente la fonction principal, obligatoire dans chaque programme (voir block)		
fonctionP ::= FONCTION PRINC PO PF AO blockFonction AF;

//Represente les methodes du programme
fonction ::= FONCTION ENTIER NOM PO parametre PF AO blockFonction AF
			| FONCTION NOM PO parametre PF AO blockFonction AF
			;

//Represente les parametres d'une fonction à la creation
parametre ::=  operation:chien V parametre 	//{: Calculatrice.traduire(chien); :}
			| operation:chien				//{: Calculatrice.traduire(chien); :}
			| ENTIER NOM
			| ENTIER NOM V parametre
			| NOM V parametre
			| NOM
			|
			;
			
/*"blockFonction" a le meme role que "block", à la différence qu'il ne peut y avoir de fonction principal à l'intérieur.
 * Utiliser pour le contenu des fonctions*/
blockFonction ::= declarationI blockFonction
				| COM blockFonction
				| affectation blockFonction
				| conditionnelle blockFonction
				| boucle blockFonction
				| retourner blockFonction
				| ecrire blockFonction
				| appel PV blockFonction
				|
				;

//Represente la declaration de variables locales dans une methode
declarationI ::= LOC ENTIER parametreD EG operation PV
				| LOC ENTIER parametreD EG valeur PV
				| LOC ENTIER parametreD PV
				
				;

//Represente le SI ... ALORS ...
conditionnelle ::= SI PO condition PF AO blockFonction AF
				| SI PO condition PF AO blockFonction AF SINON AO blockFonction AF
				;

//Represente les différentes formes d'une expression booleenne dans nos programmes
condition ::= valeur OPBOOL valeur
			| valeur OPBOOL operation:chien	//{: Calculatrice.traduire(chien); :}
			| operation:chien OPBOOL valeur	//{: Calculatrice.traduire(chien); :}
			| operation:chien1 OPBOOL operation:chien2	/*{: Calculatrice.traduire(chien1);
														   Calculatrice.traduire(chien2); :}*/
			;
			
//Represente la boucle Tant Que			
boucle ::= TQ PO condition PF AO blockFonction AF 
		;

//La fonction ecrire
ecrire ::= ECRIRE PO operation:chien PF PV //{: Calculatrice.traduire(chien); :}
		| ECRIRE PO valeur PF PV
		;
		
//Represente le return d'une methode		
retourner ::= RET operation:chien PV		//{: Calculatrice.traduire(chien); :}
			| RET valeur PV
			;
								
//Represente l'appel d'une fonction		
appel ::= APPEL:i NOM:j PO parametreA:k PF 	{: RESULT = i+j+"("+k+")"; :}
		| APPEL:i NOM:j PO PF				{: RESULT = i+j+"()"; :}
		;

//Parametre d'une methode passé en entree lors de son appel		
parametreA ::= operation:i V parametreA:j	{: RESULT = i+","+j; :}
			| operation:i					{: RESULT = i; :}
			| NOM:i V parametreA:j			{: RESULT = i+","+j; :}
			| NOM:i							{: RESULT = i; :}
			| NUM:i							{: RESULT = i; :}
			;